#!/usr/bin/env python3
from __future__ import annotations
import re
import sys
from pathlib import Path
from typing import Dict, List, Tuple

# --- repo locations ---
REPO = Path(__file__).resolve().parents[1]
SCRIPTS_DIR = REPO / "ConnectWise-RMM-Asio" / "Scripts"
README = REPO / "README.md"

# which file types count as scripts in the catalog
SCRIPT_EXTS = {".ps1", ".psm1", ".py", ".sh"}

# Simple synopsis detector for PowerShell files
_SYNOPSIS_RE = re.compile(r"^\s*<\#.*?\.SYNOPSIS.*?\#>", re.IGNORECASE | re.DOTALL | re.MULTILINE)


def has_synopsis(p: Path) -> bool:
    if p.suffix.lower() in {".ps1", ".psm1"}:
        try:
            text = p.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            return False
        return bool(_SYNOPSIS_RE.search(text))
    # for non-PS scripts, don't enforce synopsis
    return True


def discover_scripts() -> List[Path]:
    roots: List[Path] = []
    if SCRIPTS_DIR.is_dir():
        for p in SCRIPTS_DIR.rglob("*"):
            if p.is_file() and p.suffix.lower() in SCRIPT_EXTS:
                roots.append(p)
    return sorted(roots)


def section_for(p: Path) -> str:
    parts = p.parts
    # Expect: ConnectWise-RMM-Asio / Scripts / <Platform> / file
    try:
        idx = parts.index("Scripts")
        if idx + 1 < len(parts):
            return parts[idx + 1]
    except ValueError:
        pass
    return "Misc"


def build_catalog_data(paths: List[Path]) -> Dict[str, List[Tuple[str, bool]]]:
    data: Dict[str, List[Tuple[str, bool]]] = {}
    for p in paths:
        rel = p.relative_to(REPO).as_posix()
        syn = has_synopsis(p)
        print(f"[build_catalog] ITEM path={rel} syn={'YES' if syn else 'NO'}")
        sec = section_for(p)
        data.setdefault(sec, []).append((rel, syn))
        if p.name.lower().startswith("m365cleanup"):
            print(f"[build_catalog] ITEM-M365 matched for path={rel}")
    # sort entries within each section
    for sec in list(data.keys()):
        data[sec].sort(key=lambda t: t[0].lower())
    return data


def render_readme(data: Dict[str, List[Tuple[str, bool]]]) -> str:
    lines: List[str] = []
    header = "# MSP Resources\n\nScript catalog generated by CI.\n\n"
    lines.append(header)
    for sec in sorted(data.keys()):
        lines.append(f"## {sec}\n\n")
        for rel, syn in data[sec]:
            base = Path(rel).name
            syn_tag = " (synopsis)" if syn else ""
            lines.append(f"- [{base}]({rel}){syn_tag}\n")
        lines.append("\n")
    return "".join(lines)


def write_readme(new_md: str) -> None:
    prev = README.read_text(encoding="utf-8") if README.exists() else ""
    if new_md != prev:
        README.write_text(new_md, encoding="utf-8")
        print("Updated README.md with grouped catalog.")
    else:
        print("README.md already up-to-date.")


def validate_presence(data: Dict[str, List[Tuple[str, bool]]]) -> None:
    """Write a marker file if any discovered script base name is absent from README."""
    txt = README.read_text(encoding="utf-8") if README.exists() else ""
    missing: List[str] = []
    for _, items in sorted(data.items()):
        for rel, _syn in items:
            base = Path(rel).stem
            if base.lower() not in txt.lower():
                missing.append(base)
    marker = REPO / ".catalog_validation_failed"
    if missing:
        try:
            marker.write_text("missing\n", encoding="utf-8")
        except Exception:
            pass
        print(f"[build_catalog] VALIDATION: missing entries in README: {', '.join(sorted(set(missing)))}")
    else:
        if marker.exists():
            try:
                marker.unlink()
            except Exception:
                pass
        print("[build_catalog] VALIDATION: all discovered scripts present in README.")


def main() -> int:
    scripts = discover_scripts()
    print(f"[build_catalog] Discovered {len(scripts)} scripts (pre-write)")
    data = build_catalog_data(scripts)
    new_md = render_readme(data)
    write_readme(new_md)
    print(f"[build_catalog] Discovered {len(scripts)} scripts")
    validate_presence(data)
    return 0


if __name__ == "__main__":
    sys.exit(main())